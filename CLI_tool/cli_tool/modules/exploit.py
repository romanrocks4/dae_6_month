"""
Exploitation module for pentestctl.
"""

import click
import subprocess
import json
from rich.console import Console
from typing import Dict, Any, Optional
from cli_tool.core.project import ProjectManager
from pathlib import Path

console = Console()


def get_current_project():
    """Get the current project from the context file."""
    try:
        # Look for the project file in the current working directory
        project_file = Path.cwd() / ".pentestctl_current_project"
        if project_file.exists():
            with open(project_file, 'r') as f:
                return f.read().strip()
        # Also check in the CLI tool root directory
        cli_tool_root = Path(__file__).parent.parent
        project_file = cli_tool_root / ".pentestctl_current_project"
        if project_file.exists():
            with open(project_file, 'r') as f:
                return f.read().strip()
    except Exception:
        pass
    return None


def save_output_for_ai(data):
    """Save command output to temporary file for AI module access."""
    try:
        # Convert data to a readable format
        output_str = json.dumps(data, indent=2)
        temp_output_file = Path(__file__).parent.parent / ".pentestctl_last_output"
        with open(temp_output_file, 'w') as f:
            f.write(output_str)
    except Exception:
        # Silently fail if we can't save the output
        pass


def run_metasploit_exploit(target: str, exploit_module: Optional[str] = None, payload: Optional[str] = None, options: Optional[Dict[str, str]] = None) -> Dict[str, Any]:
    """Run Metasploit exploit against target."""
    console.print(f"üí• Starting Metasploit exploitation on {target}")
    
    # Try to import pymetasploit3 for RPC connection
    pymetasploit_available = False
    try:
        from pymetasploit3.msfrpc import MsfRpcClient
        import pymetasploit3.msfconsole
        pymetasploit_available = True
        console.print("‚úÖ Metasploit RPC library found")
    except ImportError:
        console.print("‚ö†Ô∏è  Metasploit RPC library not found (install with: pip install pymetasploit3)")
    
    # Check if Metasploit is installed
    try:
        result = subprocess.run(["which", "msfconsole"], capture_output=True, text=True)
        if result.returncode != 0:
            message = "Metasploit framework not found."
            if pymetasploit_available:
                message += " The RPC library is installed but Metasploit framework is required."
            message += " Install with: curl https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/templates/metasploit-framework-wrappers/msfupdate.erb > msfinstall && chmod 755 msfinstall && ./msfinstall"
            
            exploit_result = {
                "target": target,
                "exploit_module": exploit_module or "auto",
                "payload": payload or "generic",
                "status": "metasploit_not_installed",
                "message": message,
                "timestamp": "2025-10-23T12:00:00Z"
            }
            
            if pymetasploit_available:
                exploit_result["details"] = {
                    "rpc_library": "Available",
                    "framework": "Not installed",
                    "next_steps": "Install Metasploit framework"
                }
            else:
                exploit_result["details"] = {
                    "rpc_library": "Not installed",
                    "framework": "Not installed",
                    "next_steps": "Install both Metasploit framework and RPC library"
                }
            
            return {
                "status": "success",
                "exploit": exploit_result
            }
    except Exception as e:
        return {
            "status": "error",
            "error": f"Unable to check Metasploit installation: {str(e)}"
        }
    
    # If we get here, Metasploit is installed
    console.print("‚úÖ Metasploit framework found")
    
    # Provide information about next steps for full integration
    exploit_result = {
        "target": target,
        "exploit_module": exploit_module or "auto",
        "payload": payload or "generic",
        "status": "framework_installed",
        "message": "Metasploit framework is installed. For full integration, start the RPC server with: msfrpcd -P yourpassword",
        "timestamp": "2025-10-23T12:00:00Z"
    }
    
    if pymetasploit_available:
        exploit_result["details"] = {
            "rpc_library": "Available",
            "framework": "Installed",
            "next_steps": "Start RPC server and implement full integration"
        }
    else:
        exploit_result["details"] = {
            "rpc_library": "Not installed",
            "framework": "Installed",
            "next_steps": "Install RPC library for full integration"
        }
    
    return {
        "status": "success",
        "exploit": exploit_result
    }


def display_exploit_results(results: Dict[str, Any]):
    """Display exploit results."""
    if results.get("status") != "success":
        console.print(f"‚ùå Exploitation failed: {results.get('error', 'Unknown error')}")
        return
    
    exploit_data = results.get("exploit", {})
    console.print(f"üí• Exploitation Results:")
    console.print(f"   Target: {exploit_data.get('target', 'Unknown')}")
    console.print(f"   Module: {exploit_data.get('exploit_module', 'Unknown')}")
    console.print(f"   Payload: {exploit_data.get('payload', 'Unknown')}")
    console.print(f"   Status: {exploit_data.get('status', 'Unknown')}")
    console.print(f"   Message: {exploit_data.get('message', 'No message')}")
    
    # Show additional details if available
    if "details" in exploit_data:
        console.print(f"   Details: {exploit_data['details']}")

@click.group()
def exploit():
    """Exploitation commands."""
    pass

@exploit.command()
@click.option("--target", "-t", required=True, help="Target to exploit")
@click.option("--module", "-m", default=None, help="Specific exploit module to use")
@click.option("--payload", "-p", default=None, help="Payload to use")
@click.option("--options", "-o", default=None, help="Additional options (JSON format)")
@click.option("--project-name", "-n", help="Project name to save results to")
def run(target, module, payload, options, project_name):
    """Run exploitation against target using Metasploit."""
    # Use current project if none specified
    if not project_name:
        project_name = get_current_project()
    
    # Parse options if provided
    parsed_options = {}
    if options:
        try:
            parsed_options = json.loads(options)
        except json.JSONDecodeError:
            console.print("‚ùå Invalid JSON in options")
            return
    
    # Run the exploit
    results = run_metasploit_exploit(target, module, payload, parsed_options)
    display_exploit_results(results)
    
    # Save results to project if specified
    if project_name:
        pm = ProjectManager(project_name)
        pm.save_finding("metasploit", target, results)
        # Save detailed log
        pm.save_detailed_log("metasploit", target, results, "exploit")
    
    # Save output to temporary file for AI module
    save_output_for_ai(results)